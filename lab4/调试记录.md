# 2048Game   调试记录
---
#### 2021/4/19  可改进的地方
- [ ] 支持保存记录、读取历史记录的游戏设置：
需保存数据有：
  table size，table content
  player Modle，Winnum modle
  each player：name，score
  double model： whos turn
保存命令 -save *** （文件名）
读取文件 -history ***（文件名）
历史记录列表 -list
#### 学习
  file 使用
## lab4
##### Elin 2021/4/9 
#### 可改进的地方
- [ ] 函数的命名，辨识度不够高
#### 需求
- [x]  增加可定义维数的参数。命令行设置table大小
- [x]  可判断用户无效的设置命令并令其重新输入    
- [x]  对于双人模式，增加一个Cheat功能。可判断是否有唯一方向可移动，可识别cheat命令
    
      增加一个新的命令 c。比如，两个用户u1,u2对局的情况下，如果u1在输入移动命令之前，输入“c [要求参数]”(在c和要求参数间用空格隔开，要求参 数是无空格的字符串，例如:“c 给u1发红包”)，那么在接下来u2的操作中，如果出现了只有一个方向能够移动的情况，比如只能输入'w'，系统先提示u2:" [要求参数] 同意请按’w'"(例如:“给u1发红包 同意请按'w'”)。这时候如果u2用户输入了'w'之外无 效的键，u2需要继续输入，只到输入‘w’为止。之后游戏正常进行，同时该cheat命令失效。
      (注意:一盘游戏中，u1、u2无论谁发起过一次cheat功能，后面c命令就无法使用)

#### 实现
- [x] 怎么实现main函数参数读入的功能

    ```c++
        int main(int argc,chart* args);
    ```
   **避开了这个实现方式**

- [x] 判断只有一个方向有有效操作
      原来的moveDir可以进行如此判断，但同时也改变了原来的数组；
      且该操作需要四个方向都尝试一次
      -->拷贝当前的数组，在副本上分别进行试验；用bitset存；
         当至少有两个方向有有效移动时就可以判断不满足cheat生效指令；bitset的含1位代表对应方向上可操作
- [x] cheat命令，在commend中进行判断，在 oneMove 中进行移动唯一性判断和cheat释放的操作。cheat命令也要考虑cheatbuff状态。
  gamebox需要增加变量（enum）cheatbuff，标记nocheat，cheating，cheated三个状态。
- [ ] 随机生成2或者4
    **cheat命令最终实现方式**
- [x] bitset操作增加了不必要的细节，被抛弃。
#### 编写bug

- [ ] 预判只有一个方向可行出错
      写test
```c++
bool GameBox::onlyDir(int *dir){
	bool possibleMove=0,canMove=0;
	for(int i=1;i<=4;++i){
		possibleMove=tryMove(i);
		if(possibleMove&&canMove) return 0;
		canMove=1;
		*dir=i;
	}
	return 1;//wrong
}
```
```c++
bool GameBox::onlyDir(int *dir){
	bool possibleMove=0,canMove=0;
	for(int i=1;i<=4;++i){
		possibleMove=tryMove(i);
		if(possibleMove&&canMove) return 0;
		canMove=1;
		*dir=i;
	}
	return canMove;//right
}
```
![预判只有一个方向可行出错](./img/lab401.png)
![](.img/../img/lab403.png)
重大失误：尝试移动的环节与原table共用colliation，导致totalFulled“莫名”减少
- [x] scanf不能把换行符读调导致fgets读入换行
![scanf不能把换行符读调导致fgets读入换行](./img/lab402.png)
```c++
//解决方法
scanf("%d",&edgeSize);fflush(stdin);//fflush清空键盘缓冲区的残留
```
#### 学习
1 getchar()简介

getchar()是C语言中的函数，C++中也包含了该函数。getchar()函数的作用是从标准的输入stdin中读取字符。也就是说，getchar()函数以字符为单位对输入的数据进行读取。

2 getchar()读取缓冲区方式

在控制台中通过键盘输入数据时，以回车键作为结束标志。当输入结束后，键盘输入的数据连同回车键一起被输入到输入缓冲区中。在程序中第一次调用getchar()函数从输入缓冲区中读取一个字节的数据。需要注意的是，如果此时在程序中第二次调用getchar()函数，因为此时输入缓冲区中还有回车键的数据没有被读出，第二个getchar()函数读出的是回车符。

例如如下代码
```c++
char test1 = getchar();
 
char test2 = getchar();
```
此时在控制台中输入字符“a”并且按下回车键，test1的值是字符“a”，而test2的值是“\n”，如图1所示。

 

图1 test1和test2的值

3 解决方法

可以使用rewind()函数来清理输入缓冲区中的数据。该函数的格式为
```c++
void rewind( FILE* stream );
```
其中，参数stream表示指向FILE结构的指针，即为指定的流。该函数的作用是将文件指针移动到文件的起始位置处。rewind()函数清理指定流中的错误指示符以及文件结束指示符。将“2 getchar()读取缓冲区方式”中提到的代码修改为
```c++
char test1 = getchar();
 
rewind(stdin);
 
char test2 = getchar();
 
rewind(stdin);
```
在控制台中，首先输入字符“a”然后按下回车键。getchar()函数从输入缓冲区中读取字符“a”，之后调用rewind()函数清理输入缓冲区中的数据，stdin表示输入缓冲区的指针；之后再在控制台中输入字符“b”，然后按下回车键，getchar()函数从输入缓冲区中读取字符“b”，最后再次调用rewind()函数清理输入缓冲区中的数据。此时，test1和test2的值如图2所示。

原文链接：https://blog.csdn.net/hou09tian/article/details/80741890



---
## lab3
##### Elin 2021/3/30-2021/4/2
##### 工作时间：
- 从面向过程到面向对象：3h
- 完善：2h
- 更进一步：5h
- Markdown：40min
#### 编写bug：
- switch 语句中的 continue 将导致其后所有语句被跳过（无法执行）
    <img src="./img/125416.png" title="stop">
- 并未达到游戏结束条件，而游戏却终止:和内存无关，是合并后没有将numFulled- -。
>因为游戏结束需要满足：所有格子被填满，且相邻格子不能再合并的条件，因此之前没有发现该问题
>(是第二版lab2中漏写了，第一版没有这个问题）。下图恰是相邻格子不能合并的情况。
>>进一步，若判断相邻格子不能合并时，将空格（table[ ]=0）看作通配格，则numFulled即可省略，不需记录。
>>但效率上看，记录numFulled在格子数量较大时。时间复杂度降低。O(1)<->O(n)。
- switch 语句中没有break（原来为下落语句，修改后未将其添上）
  ![break](./img/80302.png)
- **strcmp( )==0！！！！！！！！！！！**
  ![strcmp](./img/80403.png)
- 打印的空格（不同数字及空格的总的大小）---以后最好专门测试一下显示
  ![table](./img/44241.png)
#### 技术实现：
- test model 未生效
	-t 并不是在编译程序时设置，而是在调用可执行文件时。因为-t时main函数的参数，所以在main函数启动时被读取。args字符数组指针中依序存放了调用指令（类似scanf读入，以空格/table为界）args[0]是地址。
- 疑似内存泄露
  ![stop](./img/125416.png)
       try：delete name[]后，将name置空
	name=NULL；
- 封装：
> - 封装过程。在main中只涉及信息的解说和传递（命令行、玩家、gamebox），将gamebox的具体过程全部封装。
> - 把用户指令读入和解读放在player class 里，进一步封装
> - 把游戏状态封装，主程序中仅余：游戏中，用户输入指令（single模式）。
- [ x ] 可改进：是否增加第三个类，将游戏开始、进行、结束过程封装与gamebox分离？
  增加gameplay类，操作游戏。
  “彻底的OOP”式编程，创建一个gameplay类的对象contr，全盘OOP。
    **戴开宇老师意见：best：写外部文件进行配置**
> - 用 const 取代 #define

***问题：playing是否传入对象，以便最后的欢呼？（可重用性和游戏体验的矛盾***

#### 游戏功能完善：
- [x] 游戏达到2048后可选择继续游戏
- [ ] 存放历史记录和排名
- [ ] 默认游戏玩家名
- [ ] 双人模式不允许无效操作

#### 待学习：
- [ ] 重载运算符
  ![operator](./img/112835.png)
- [ ] static 成员函数与变量的使用
- [ ] extern
  ![extern](./img/85349.png)
- [ ] makefile
> https://blog.csdn.net/iteye_14736/article/details/81306340
> >makefile关系到了整个工程的编译规则。一个工程中的源文件不计数，其按类型、功能、模块分别放在若干个目录中，makefile定义了一系列的规则来指定，哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作，因为makefile就像一个Shell脚本一样，其中也可以执行操作系统的命令。makefile带来的好处就是——“自动化编译”，一旦写好，只需要一个make命令，整个工程完全自动编译，极大的提高了软件开发的效率。make是一个命令工具，是一个解释makefile中指令的命令工具，一般来说，大多数的IDE都有这个命令，比如：Delphi的make，Visual C++的nmake，Linux下GNU的make。可见，makefile都成为了一种在工程方面的编译方法。

 



